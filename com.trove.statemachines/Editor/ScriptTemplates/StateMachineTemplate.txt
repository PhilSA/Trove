using System.Runtime.CompilerServices;
using Trove;
using Unity.Burst;
using Unity.Entities;
using Trove.PolymorphicStructs;
using Trove.Statemachines;
using Unity.Transforms;
using UnityEngine;

#region States

/// <summary>
/// This is the polymorphic state buffer element.
/// </summary>
[InternalBufferCapacity(8)] // TODO: tweak internal capacity
public struct #SCRIPTNAME#State : IBufferElementData, IVersionedPoolElement, IState<#SCRIPTNAME#StateMachineGlobalStateUpdateData, #SCRIPTNAME#StateMachineEntityStateUpdateData>
{
    // Required for VersionedPool handling. Determines if the state exists in the states pool.
    public int Version { get; set; }
    // This is the generated polymorphic state struct, based on the I#SCRIPTNAME#StateMachineState polymorphic interface
    public Poly#SCRIPTNAME#State State;

    public void OnStateEnter(ref StateMachine stateMachine, ref #SCRIPTNAME#StateMachineGlobalStateUpdateData globalData,
        ref #SCRIPTNAME#StateMachineEntityStateUpdateData entityData)
    {
        State.OnStateEnter(ref stateMachine, ref globalData, ref entityData);
    }

    public void OnStateExit(ref StateMachine stateMachine, ref #SCRIPTNAME#StateMachineGlobalStateUpdateData globalData,
        ref #SCRIPTNAME#StateMachineEntityStateUpdateData entityData)
    {
        State.OnStateExit(ref stateMachine, ref globalData, ref entityData);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Update(ref StateMachine stateMachine, ref #SCRIPTNAME#StateMachineGlobalStateUpdateData globalData,
        ref #SCRIPTNAME#StateMachineEntityStateUpdateData entityData)
    {
        State.Update(ref stateMachine, ref globalData, ref entityData);
    }
}

/// <summary>
/// This is the polymorphic interface definition for our states. It inherits the IState interface.
/// </summary>
[PolymorphicStructInterface]
public interface I#SCRIPTNAME#State : IState<#SCRIPTNAME#StateMachineGlobalStateUpdateData, #SCRIPTNAME#StateMachineEntityStateUpdateData>
{ }

/// <summary>
/// This is an example state
/// </summary>
[PolymorphicStruct] 
public struct I#SCRIPTNAME#StateA : I#SCRIPTNAME#State
{
    // TODO: add state data
    
    public void OnStateEnter(ref StateMachine stateMachine, ref #SCRIPTNAME#StateMachineGlobalStateUpdateData globalData, ref #SCRIPTNAME#StateMachineEntityStateUpdateData entityData)
    {
        // TODO: implement
    } 

    public void OnStateExit(ref StateMachine stateMachine, ref #SCRIPTNAME#StateMachineGlobalStateUpdateData globalData, ref #SCRIPTNAME#StateMachineEntityStateUpdateData entityData)
    {
        // TODO: implement
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Update(ref StateMachine stateMachine, ref #SCRIPTNAME#StateMachineGlobalStateUpdateData globalData, ref #SCRIPTNAME#StateMachineEntityStateUpdateData entityData)
    {
        // TODO: implement
    }
}

/// <summary>
/// This is an example state
/// </summary>
[PolymorphicStruct]
public struct I#SCRIPTNAME#StateB : I#SCRIPTNAME#State 
{
    // TODO: add state data
    
    public void OnStateEnter(ref StateMachine stateMachine, ref #SCRIPTNAME#StateMachineGlobalStateUpdateData globalData, ref #SCRIPTNAME#StateMachineEntityStateUpdateData entityData)
    {
        // TODO: implement
    }

    public void OnStateExit(ref StateMachine stateMachine, ref #SCRIPTNAME#StateMachineGlobalStateUpdateData globalData, ref #SCRIPTNAME#StateMachineEntityStateUpdateData entityData)
    {
        // TODO: implement
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Update(ref StateMachine stateMachine, ref #SCRIPTNAME#StateMachineGlobalStateUpdateData globalData, ref #SCRIPTNAME#StateMachineEntityStateUpdateData entityData)
    {
        // TODO: implement
    }
}
#endregion

#region State Update Datas
/// <summary>
/// This represents the global data that our state updates may need access to.
/// Here you can store time, singletons, component lookups, native collections, etc....
/// </summary>
public struct #SCRIPTNAME#StateMachineGlobalStateUpdateData
{
    public float DeltaTime;
    // TODO: add/change global data

    public #SCRIPTNAME#StateMachineGlobalStateUpdateData(float deltaTime)
    {
        DeltaTime = deltaTime;
    }
}

/// <summary>
/// This represents the per-entity data that our state updates may need access to.
/// Note that if you need access to a component by reference, you can do so by using RefRW<T>. The LocalTransform
/// field demonstrates this here.
/// </summary>
public struct #SCRIPTNAME#StateMachineEntityStateUpdateData
{
    public Entity Entity;
    public DynamicBuffer<#SCRIPTNAME#State> StatesBuffer;
    public RefRW<LocalTransform> LocalTransform;
    // TODO: add/change entity data
    
    public #SCRIPTNAME#StateMachineEntityStateUpdateData(
        Entity entity,
        DynamicBuffer<#SCRIPTNAME#State> statesBuffer,
        RefRW<LocalTransform> localTransform)
    {
        Entity = entity;
        StatesBuffer = statesBuffer;
        LocalTransform = localTransform;
    }
}
#endregion

#region Example System
/// <summary>
/// An example of a system that schedules a state machine update job
/// </summary>
[BurstCompile]
public partial struct Example#SCRIPTNAME#StateMachineStateMachineSystem : ISystem
{
    [BurstCompile]
    public void OnCreate(ref SystemState state)
    {
        state.RequireForUpdate<#SCRIPTNAME#State>();
    }
    
    [BurstCompile]
    public void OnUpdate(ref SystemState state)
    {
        state.Dependency = new #SCRIPTNAME#StateMachineStateMachineUpdateJob
        {
            // Here we build the global data and pass it to the job
            GlobalData = new #SCRIPTNAME#StateMachineGlobalStateUpdateData(SystemAPI.Time.DeltaTime), 
        }.ScheduleParallel(state.Dependency); 
    }
    
    [BurstCompile]
    public partial struct #SCRIPTNAME#StateMachineStateMachineUpdateJob : IJobEntity
    {
        public #SCRIPTNAME#StateMachineGlobalStateUpdateData GlobalData;
        
        public void Execute(
            Entity entity, 
            ref StateMachine stateMachine, 
            RefRW<LocalTransform> localTransform,
            ref DynamicBuffer<#SCRIPTNAME#State> statesBuffer)
        {
            // Here we build the per-entity data
            #SCRIPTNAME#StateMachineEntityStateUpdateData entityData = new #SCRIPTNAME#StateMachineEntityStateUpdateData(
                entity, 
                statesBuffer,
                localTransform);

            // Update the state machine
            StateMachineUtilities.Update(ref stateMachine, ref statesBuffer, ref GlobalData, ref entityData);
        }
    }
}
#endregion

#region Example Authoring
/// <summary>
/// This an example of an authoring component for this state machine
/// TODO: move this code out of this file, to a new file named "TemplateStateMachineStateMachineAuthoring". MonoBehaviours need their file name to match.
/// </summary>
class #SCRIPTNAME#StateMachineStateMachineAuthoring : MonoBehaviour
{
    class Baker : Baker<#SCRIPTNAME#StateMachineStateMachineAuthoring>
    {
        public override void Bake(#SCRIPTNAME#StateMachineStateMachineAuthoring authoring)
        {
            Entity entity = GetEntity(authoring, TransformUsageFlags.None);

            // Add the state machine components
            StateMachineUtilities
                .BakeStateMachineComponents<#SCRIPTNAME#State, #SCRIPTNAME#StateMachineGlobalStateUpdateData, #SCRIPTNAME#StateMachineEntityStateUpdateData>(
                    this,
                    entity,
                    out StateMachine stateMachine,
                    out DynamicBuffer<#SCRIPTNAME#State> statesBuffer);

            // Initialize the state machine buffers with an initial capacity
            StateMachineUtilities
                .InitStateMachine<#SCRIPTNAME#State, #SCRIPTNAME#StateMachineGlobalStateUpdateData, #SCRIPTNAME#StateMachineEntityStateUpdateData>(
                    ref stateMachine,
                    ref statesBuffer,
                    8);

            // Create a few states and remember their StateHandles.
            StateMachineUtilities
                .CreateState<#SCRIPTNAME#State, #SCRIPTNAME#StateMachineGlobalStateUpdateData, #SCRIPTNAME#StateMachineEntityStateUpdateData>(
                    ref statesBuffer,
                    default,
                    out StateHandle state1Handle);
            StateMachineUtilities
                .CreateState<#SCRIPTNAME#State, #SCRIPTNAME#StateMachineGlobalStateUpdateData, #SCRIPTNAME#StateMachineEntityStateUpdateData>(
                    ref statesBuffer,
                    default,
                    out StateHandle state2Handle);

            // Set state data, now that we have all of our state handles created.
            // Note: it can be useful to set state data after creating all of our state handles, in cases where
            // Our states must store state handles to transition to. If not, we could've also set state data directly
            // in the "CreateState" function.
            StateMachineUtilities.TrySetState<#SCRIPTNAME#State, #SCRIPTNAME#StateMachineGlobalStateUpdateData, #SCRIPTNAME#StateMachineEntityStateUpdateData>(
                ref statesBuffer,
                state1Handle,
                new #SCRIPTNAME#State
                {
                    // TODO: set state data
                    State = new I#SCRIPTNAME#StateA
                    {
                        
                    },
                });
            StateMachineUtilities.TrySetState<#SCRIPTNAME#State, #SCRIPTNAME#StateMachineGlobalStateUpdateData, #SCRIPTNAME#StateMachineEntityStateUpdateData>(
                ref statesBuffer,
                state2Handle,
                new #SCRIPTNAME#State
                {
                    // TODO: set state data
                    State = new I#SCRIPTNAME#StateB
                    {
                        
                    },
                });

            // Set an initial state for our state machine. This is a state the state machine will automatically 
            // transition to the first time it updates.
            // Note: we don't want to set the "stateMachine.CurrentState" here, because if we do that here in baking,
            // the current state would not get an "OnStateEnter" at runtime.
            stateMachine.InitialState = state1Handle;

            // Write back any changes to the stateMachine component
            SetComponent(entity, stateMachine);
        }
    }
}
#endregion